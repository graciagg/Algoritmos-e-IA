---
title: "Actividad 3 Estadística y R"
author: "Gorka Suárez González"
date: "2025-01-21"
output: html_document
---

```{r}

rm(list = ls()) 

library(moments)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(car)
library(gtsummary)
library(gt)
library(patchwork)
library(stats)
library(factoextra)
library(pheatmap)


```

Seleccionamos el directorio y cargamos la base de datos “Dataset expresión genes” con la que trabajaremos durante la actividad. Con la función any(is.na(df)) comprobamos que no haya missings en los datos proporcionados.

```{r}

path <- "~/Desktop/UNIR/Estadística y R para Ciencias de la Salud/Actividades /Actividad 3"
setwd(path)
df <- read.csv("Dataset expresion genes.csv")
View(df)
any(is.na(df))

```


```{r}

genes <- grep("AQ_", colnames(df), value = TRUE)
genes_df <- df[, genes]
any(is.na(genes_df))

```


### ---- 1.	Comprobar la normalidad de los genes y realizar una interpretación de los resultados obtenidos ----

                                             Comprobacion de la normalidad
                        
```{r}
nombre_genes<-colnames(genes_df) 
resultados<-data.frame(gen=nombre_genes,p_valor=numeric((length(genes_df))))

```

Gen sera igual a los elementos contenidos en el vector nombre_genes
 valor_p de momento la creo vacia pero establezco su longitud para que sea la misma que elementos tiene el vector nomre_genes

 Uso de notacion cientifica con 3 cifras significativas debido a los valores tan bajos obtenidos
 En caso de hacer  "scientific = F", aun cogiendo 5 cifras seguiria siendo 0 que visualmente queda peor


 Principios del Shapiro Test
   H0 si p_value > = 0.05 -> Asumo normalidad 
   H1 si p_value < 0.05   -> Asumo que no hay normalidad en mis datos
   
   
```{r}
for (i in 1:length(nombre_genes)) { 
  normalidad <- shapiro.test(df[[nombre_genes[i]]])
  resultados[i, "p_valor"] <- signif(normalidad$p.value,3) 
}


resultados$interpretacion <- numeric(length(genes)) # Creo la columna vacia para la interpretacion
resultados$p_valor<- as.numeric(resultados$p_valor)

# Añadir al dataframe una columna donde se interprete la prueba de normalidad y otra donde se especifique el tipo de test usado


for (i in 1:nrow(resultados)) {
  resultados[i, "interpretacion"] <- ifelse(resultados$p_valor[i] < 0.05, "no presenta normalidad", "normalidad")
}


resultados$test<-numeric(length(genes)) # Creo la columna vacia para el tipo de test usado

for (i in 1:nrow(resultados)){
  resultados[i, "test"]<-  (" Shapiro Test")
}


```


### ---- 1.2	Creacion de la tabla 1. ----
 (Al ejecutar el siguiente chunk aparecen 2 objetos *shiny.tag*, el importante es el segundo que es el que mas completo esta)

```{r}
resultados %>%
  gt()


# Aplicar estilos al cuerpo de la tabla

tabla1 <- resultados %>%
  gt() %>%
  tab_style(
    style = cell_fill(color = "lightblue"),  
    locations = cells_body(
      columns = "gen"                       
    )
  ) %>%
  tab_style(
    style = cell_text(color = "red"),     
    locations = cells_body(
      columns = "interpretacion",           
      rows = interpretacion == "no presenta normalidad"              
    )
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %>%
  tab_header(title = md("**Tabla 1**"), subtitle = md("**Comprobar normalidad de los genes**") )

print(tabla1)
```


### ----  2. 	PCA ----

### ----  2.1. Aplicación del PCA y elecciones de componentes principales ----

```{r}

pca_genes <- prcomp(genes_df, scale = TRUE)

names(pca_genes)

head(pca_genes$rotation)[, 1:5]
dim(pca_genes$rotation)

head(pca_genes$x)[,1:5]

# Desviación estandar de cada componente principal
pca_genes$sdev

# Varianza explicada por cada componente

pca_genes$sdev^2
summary(pca_genes)

## Eleccion del número de componentes principales

# Scree plot: Una forma es generando un scree plot que represente los eigenvalores ordenador de mayor a menor. Con la función fviz_screeplot() del paquete factoextra podemos obtener esta representación, sin importar qué función hemos utilizado para generar los componentes principales.

fviz_screeplot(pca_genes, addlabels = TRUE, ylim = c(0, 20))

# Contribución de variables: Top 10 variables

fviz_contrib(pca_genes, choice = "var", axes = 1, top = 10) #La línea roja discontinua indica el valor medio de contribución.

# Proporción de varianza explicada y acumulada

PVE <- 100*pca_genes$sdev^2/sum(pca_genes$sdev^2)
PVE

par(mfrow = c(1,2))

plot(PVE, type = "o", 
     ylab = "PVE", 
     xlab = "Componente principal", 
     col = "blue")
plot(cumsum(PVE), type = "o", 
     ylab = "PVE acumulada", 
     xlab = "Componente principal", 
     col = "brown3")
```

### ----  2.2. Aplicación del PCA y elecciones de componentes principales ----

```{r}
# Representación de las observaciones

library(factoextra)

fviz_pca_ind(pca_genes, geom.ind = "point", 
             col.ind = "#FC4E07", 
             axes = c(1, 2), 
             pointsize = 1.5) 

# Representación de las variables

fviz_pca_var(pca_genes, col.var = "cos2", 
             geom.var = "arrow", 
             labelsize = 2, 
             repel = FALSE)

var <- get_pca_var(pca_genes)
var

# -- ESTAS DOS SON VARIACIONES DE LAS OTRAS, EN LAS DIAPOS EXPLICA MÁS O MENOS LOS SIGNIFICADOS --
fviz_pca_ind(pca_genes, pointsize = "cos2",
            pointshape = 21,
            fill = "yellow",
            repel = TRUE)

fviz_pca_biplot(pca_genes, repel = TRUE,
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969" # Individuals color
  )
# Biplot

biplot(pca_genes, scale = 0, cex = 0.5, col = c("dodgerblue3", "deeppink3"))

```
